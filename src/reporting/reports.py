"""
Reporting Module.

Generate reports and visualizations from backtest results.
"""

from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

from ..core.models import BacktestResult


# =============================================================================
# REPORT GENERATOR
# =============================================================================

class ReportGenerator:
    """
    Generate markdown reports with charts.
    """

    def generate_markdown(
        self,
        result: BacktestResult,
        benchmark: Optional[Dict[str, float]] = None,
    ) -> str:
        """Generate markdown report content."""

        benchmark = benchmark or {}

        report = f"""# ðŸ“Š Trading Strategy Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Strategy:** {result.strategy_name}
**Periods:** {len(result.portfolio_values)}

---

## ðŸ“ˆ Performance Summary

| Metric | Value |
|--------|-------|
| Total Return | {result.total_return:+.2%} |
| Sharpe Ratio | {result.sharpe_ratio:.2f} |
| Max Drawdown | {result.max_drawdown:.2%} |
| Win Rate | {result.win_rate:.1%} |
| Number of Trades | {result.num_trades} |
| Initial Capital | ${result.initial_capital:,.2f} |
| Final Value | ${result.final_value:,.2f} |

"""

        if benchmark:
            asset_a = benchmark.get('asset_a', 0)
            asset_b = benchmark.get('asset_b', 0)
            asset_5050 = benchmark.get('50_50', 0)
            alpha_5050 = result.total_return - asset_5050
            alpha_a = result.total_return - asset_a
            alpha_b = result.total_return - asset_b
            report += (
                "## ðŸ“Š Benchmark Comparison\n\n"
                "| Benchmark | Return | Alpha |\n"
                "|-----------|--------|-------|\n"
                f"| Strategy | **{result.total_return:+.2%}** | - |\n"
                f"| Asset A (BTC) | {asset_a:+.2%} | {alpha_a:+.2%} |\n"
                f"| Asset B (ETH) | {asset_b:+.2%} | {alpha_b:+.2%} |\n"
                f"| 50/50 B&H | {asset_5050:+.2%} | **{alpha_5050:+.2%}** |\n\n"
            )

        report += """## ðŸ“ Notes

- All returns include simulated transaction fees
- Max drawdown represents the largest peak-to-trough decline
- Sharpe ratio is annualized assuming 4h candle frequency

---

*Report generated by TradeBot v2.0*
"""

        return report

    def save(
        self,
        result: BacktestResult,
        output_path: str,
        benchmark: Optional[Dict[str, float]] = None,
    ) -> None:
        """Save report to file."""
        content = self.generate_markdown(result, benchmark)

        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)

        with open(output_path, 'w') as f:
            f.write(content)


# =============================================================================
# CHART GENERATOR
# =============================================================================

class ChartGenerator:
    """
    Generate performance charts using matplotlib.
    """

    def __init__(self):
        # Lazy import matplotlib
        self._plt = None

    def _get_plt(self):
        if self._plt is None:
            import matplotlib.pyplot as plt
            self._plt = plt
        return self._plt

    def plot_performance(
        self,
        result: BacktestResult,
        prices_a: Optional[List[float]] = None,
        prices_b: Optional[List[float]] = None,
        output_path: Optional[str] = None,
    ) -> None:
        """Plot portfolio performance vs benchmarks."""
        plt = self._get_plt()

        fig, ax = plt.subplots(figsize=(12, 6))

        epochs = range(len(result.portfolio_values))

        # Normalize to 1.0
        norm_portfolio = [v / result.initial_capital for v in result.portfolio_values]
        ax.plot(epochs, norm_portfolio, label=f'Strategy ({result.strategy_name})',
                linewidth=2, color='green')

        if prices_a:
            norm_a = [p / prices_a[0] for p in prices_a]
            ax.plot(epochs, norm_a, label='Asset A (BTC)',
                    linewidth=1, alpha=0.7, color='orange')

        if prices_b:
            norm_b = [p / prices_b[0] for p in prices_b]
            ax.plot(epochs, norm_b, label='Asset B (ETH)',
                    linewidth=1, alpha=0.7, color='blue')

        ax.axhline(y=1.0, color='black', linestyle='--', alpha=0.3)
        ax.set_title(f'Strategy Performance: {result.strategy_name}', fontsize=14)
        ax.set_xlabel('Epoch')
        ax.set_ylabel('Growth (1.0 = initial)')
        ax.legend()
        ax.grid(True, alpha=0.3)

        plt.tight_layout()

        if output_path:
            Path(output_path).parent.mkdir(parents=True, exist_ok=True)
            plt.savefig(output_path, dpi=150, bbox_inches='tight')
            plt.close()
        else:
            plt.show()

    def plot_allocations(
        self,
        result: BacktestResult,
        output_path: Optional[str] = None,
    ) -> None:
        """Plot allocation over time."""
        plt = self._get_plt()

        fig, ax = plt.subplots(figsize=(12, 4))

        epochs = range(len(result.allocations))

        alloc_a = [a.asset_a for a in result.allocations]
        alloc_b = [a.asset_b for a in result.allocations]
        alloc_cash = [a.cash for a in result.allocations]

        ax.stackplot(
            epochs, alloc_a, alloc_b, alloc_cash,
            labels=['Asset A', 'Asset B', 'Cash'],
            colors=['orange', 'blue', 'green'],
            alpha=0.7
        )

        ax.set_title('Portfolio Allocation Over Time', fontsize=14)
        ax.set_xlabel('Epoch')
        ax.set_ylabel('Allocation')
        ax.legend(loc='upper right')
        ax.set_ylim(0, 1)
        ax.grid(True, alpha=0.3)

        plt.tight_layout()

        if output_path:
            Path(output_path).parent.mkdir(parents=True, exist_ok=True)
            plt.savefig(output_path, dpi=150, bbox_inches='tight')
            plt.close()
        else:
            plt.show()

    def plot_drawdown(
        self,
        result: BacktestResult,
        output_path: Optional[str] = None,
    ) -> None:
        """Plot drawdown chart."""
        plt = self._get_plt()

        fig, ax = plt.subplots(figsize=(12, 3))

        epochs = range(len(result.portfolio_values))

        # Calculate drawdown
        values = result.portfolio_values
        peak = values[0]
        drawdown = []

        for v in values:
            if v > peak:
                peak = v
            dd = (peak - v) / peak if peak > 0 else 0
            drawdown.append(-dd * 100)

        ax.fill_between(epochs, 0, drawdown, color='red', alpha=0.5)
        ax.set_title('Portfolio Drawdown', fontsize=14)
        ax.set_xlabel('Epoch')
        ax.set_ylabel('Drawdown %')
        ax.grid(True, alpha=0.3)

        plt.tight_layout()

        if output_path:
            Path(output_path).parent.mkdir(parents=True, exist_ok=True)
            plt.savefig(output_path, dpi=150, bbox_inches='tight')
            plt.close()
        else:
            plt.show()
